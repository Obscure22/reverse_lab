<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Obscure RE and MA Dojo</title>
    
    <!-- link to fontawesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <!-- link to css file -->
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
      <a href="/reverse_lab" class="logo">Obscure_</a>
          <ul class="nav-links">
              <li><a href="../ctf_reversing/re.html">CTF Reverse Engineering</a></li>
          </ul>
    </nav>
    <section class="container">
        <section class="container-title">
            <h1>Malware Sample - Academic Exam</h1>
            <div class="post__bottom">
                <div class="post__author">
                    <a href="#" aria-label="ObscureRe">
                        <img class="post__author-image" src="../img/logo.png"
                            alt="Obscure's Picture">
                    </a>
                </div>
                <span>
                    Obscure_ &nbsp;·&nbsp; <span id="reading-time"></span>
                </span>
            </div>
        </section>
        <section>
            <h2>Introduction</h2>
            <p>
                This document details the analysis of a malware sample assigned for the <strong>Malware Analysis and Incident Forensics</strong> university exam at <strong>Sapienza University of Rome</strong>.
                The analysis focuses on understanding the internal structure, execution flow, and malicious capabilities of the sample.
            </p>
        </section>
        <section>
            <h2>Static Analysis</h2>
            <h3>Packing Detection</h3>
                <p>
                    Examining the sample with <strong>PE Studio</strong> quickly reveals numerous details. The sections are named UPX0 and UPX1. The entry point is not located in the first section. 
                    Both sections have write and execute permissions, the UPX1 section exhibits a high level of entropy, and the virtual size of the first section is significantly larger than its raw size. 
                    Since the entry point is located in the UPX1 section, it is likely that this section contains the decompression stub responsible for unpacking the original executable at runtime.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_1.png" alt="malware_academic_exam_1" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    The <strong>imports</strong> section contains some functions that are potential indicators or could reveal the sample's behavior. They are the following:
                </p>
                <ul>
                    <li><span id="inline-code">GetProcAddress</span>, <span id="inline-code">LoadLibraryA</span> which are typical of packed software that has to rebuild the IAT</li>
                    <li><span id="inline-code">MessageBoxA</span>, which means that the sample shows some message box</li>
                    <li><span id="inline-code">CryptStringToBinar</span>, which is probably used for obfuscation purposes</li>
                    <li><span id="inline-code">SHGetFolderPathA</span>, which means that the malware interacts with the filesystem</li>
                </ul>
                <br>
                <p>
                    The <strong>strings</strong> section contains a lot of junk-like strings, maybe they are just compressed or obfuscated. Some strings could reveal something about the behavior of the sample.
                    They are the following:
                </p>
                <ul>
                    <li>Function names (<span id="inline-code">GetProcAddress</span>, <span id="inline-code">LoadLibraryA</span>, <span id="inline-code">SHGetFolderPath</span>, 
                        <span id="inline-code">CryptStringToBinary</span>, <span id="inline-code">MessageBoxA</span>).</li>
                    <li>Library names (<span id="inline-code">NETAPI32.dll</span>, <span id="inline-code">kernel32.dll</span>, <span id="inline-code">shell32.dll</span>, <span id="inline-code">user32.dll</span>).</li>
                    <li>Extentions (<span id="inline-code">.jpg</span>, <span id="inline-code">.dll</span>).</li>
                    <li>A strange string <span id="inline-code">?mafuba&%s\%s.jpgUghn</span>, probably the sample create a file <span id="inline-code">.jpg</span> in a specific folder.</li>
                </ul>
                <br>
                <p>
                    The <strong>library</strong> section contains some libraries that could reveal the sample's behavior. They are the following:
                </p>
                <ul>
                    <li><span id="inline-code">shell32.dll</span>, which likely means that the sample interacts with other processes.</li>
                    <li><span id="inline-code">crypt32.dll</span>, which likely means that the malware performs some kind of encryption.</li>
                    <li><span id="inline-code">user32.dll</span>, which likely means that the sample performs user-level interactions such as showing a message box.</li>
                    <li><span id="inline-code">kernel32.dll</span>, which likely means that the sample uses some important function like 
                        <span id="inline-code">CreateFile</span>, <span id="inline-code">WriteFile</span>, <span id="inline-code">VirtualAlloc</span>, <span id="inline-code">WriteProcessMemory</span> and others.</li>
                </ul>
                <br>
                <p>
                    As section names suggested and as <strong>Detect It Easy</strong> confirmed, the sample was packed with UPX (version 3.96).
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_2.png" alt="malware_academic_exam_2" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                </p>
            <h3>Unpacking</h3>
                <p>
                    To find the Original Entry Point of a packed sample it’s necessary to locate the tail jump, that is the jump that the packed sample performs to the beginning of the unpacked code after the unpacking 
                    stub has finished its operations. There are some indicators useful to recognize the tail jump: the instruction jumps to another section (in this case from UPX1 to UPX0), 
                    after the tail jump should be a bunch of garbage bytes and the destination was previously modified by the unpacking stub.
                    <br>
                    After opening the sample in <strong>x32dbg</strong> and starting at the entry point in UPX1 (<span id="inline-code">0x460C20</span>), the first instruction is a <span id="inline-code">pusha</span>,
                    used to save the register values at startup. Most likely, there will be a corresponding <span id="inline-code">popa</span> instruction just before the tail jump.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_3.png" alt="malware_academic_exam_3" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    There is a practical and reliable technique to identify the tail jump: place an HW breakpoint on memory access on the first 4 bytes of data pushed onto the stack at 
                    <span id="inline-code">ESP</span> immediately after the first <span id="inline-code">pusha</ instruction. Before the jump there will be a <span id="inline-code">popa</span> 
                    instruction to restore the saved execution context.
                    <br>
                    The figure below highlights the tail jump located at address <span id="inline-code">0x460DC3</span>, which transfers execution to the unpacked code.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_4.png" alt="malware_academic_exam_4" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    After the tail jump, execution is transferred to a new code block starting at address <span id="inline-code">0x401E31</span>, as shown in the figure below. This address corresponds to 
                    the Original Entry Point of the unpacked executable.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_5.png" alt="malware_academic_exam_5" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    Once the OEP is identified, <strong>Scylla</strong> can be used to dump the unpacked binary. By selecting IAT Autosearch and providing the OEP address (<span id="inline-code">0x401E31</span>), 
                    <strong>Scylla</strong> automatically locates the Import Address Table and retrieves its virtual address and size. The import list can then be extracted using Get Imports; 
                    any invalid entries, as shown in the screenshot, can be manually removed. Afterward, the process memory is dumped by clicking Dump, generating a file with the <span id="inline-code">_dump</span> suffix. 
                    Finally, using Fix Dump on the generated file produces a new executable (with the <span id="inline-code">_SCY</span> suffix) containing the reconstructed IAT.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_6.png" alt="malware_academic_exam_6" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                </p>
            <h2>Dynamic Analysis</h2>
                <p>
                    After opening the unpacked sample in <strong>IDA</strong>, the binary appears as shown in the figure below.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_7.png" alt="malware_academic_exam_7" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    First, the sample invokes the function <span id="inline-code">sub_4010C0</span>. Within this function, the sample resolves and calls <span id="inline-code">GetTickCount</span>, 
                    whose API name and the corresponding <span id="inline-code">kernel32.dll</span> library are XOR-encrypted and decrypted at runtime using the key <span id="inline-code">0x30</span>.
                    Additionally, the strings required to load <span id="inline-code">GetTickCount</span> are pushed onto the stack byte by byte, a technique used to evade basic static analysis.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_7_1.png" alt="malware_academic_exam_7_1" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    The retrieved tick count is then compared against 1800000 milliseconds. If the system uptime exceeds this threshold, the function returns 0 and the sample continues execution. 
                    Otherwise, the program invokes Sleep with a timeout of <span id="inline-code">0xFFFFFFFF</span>, effectively pausing execution for an extremely long period.
                    <br><br>
                    In <span id="inline-code">sub_4011C0</span>, the sample first calls <span id="inline-code">GetCurrentProcessId</span> to retrieve the identifier of the current process. 
                    It then invokes <span id="inline-code">CreateToolhelp32Snapshot</span> with <span id="inline-code">dwFlags = 0x8</span> to obtain a snapshot used to enumerate running processes and loaded modules. 
                    The functions <span id="inline-code">Module32FirstW</span> and <span id="inline-code">Module32NextW</span> are subsequently used to iterate through the module list.
                    <br><br>
                    During this enumeration, the sample checks for the presence of specific strings within module names, including <strong>daimao</strong>, <strong>piccolo</strong>, <strong>zamasu</strong>, 
                    <strong>dercori</strong>, and <strong>frost</strong>. If any of these strings are found, execution proceeds to <span id="inline-code">sub_401000</span>. 
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_7_2.png" alt="malware_academic_exam_7_2" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    Within <span id="inline-code">sub_401000</span>, the sample calls <span id="inline-code">SHGetFolderPathA</span> with <span id="inline-code">CSIDL = 0x27</span> to retrieve the path to the user’s Pictures directory: 
                    "<span id="inline-code">C:\Users\student\Pictures</span>".
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_8.png" alt="malware_academic_exam_8" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    The function then invokes <span id="inline-code">CreateFileA</span> with <span id="inline-code">dwDesiredAccess = 0x40000000</span> (<strong>GENERIC_WRITE</strong>) to create or open a file, 
                    followed by a call to <span id="inline-code">WriteFile</span> to write the file <span id="inline-code">mafuba.jpg</span> into the previously identified Pictures directory.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_9.png" alt="malware_academic_exam_9" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    The figure below shows that the file <span id="inline-code">mafuba.jpg</span> has been successfully created in the Pictures directory.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_10.png" alt="malware_academic_exam_10" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    The routine then calls <span id="inline-code">SystemParametersInfoA</span> with <span id="inline-code">uiAction = 0x14</span>, causing the previously written image to be set as the desktop wallpaper.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_11.png" alt="malware_academic_exam_11" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    Subsequently, the function <span id="inline-code">sub_401900</span> is executed. This routine calls <span id="inline-code">SHGetFolderPathW</span> with <span id="inline-code">CSIDL = 0x07</span>
                    to retrieve the path of the Startup folder: <span id="inline-code">C:\Users\student\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span>. It then creates a copy of the current 
                    executable in this directory using <span id="inline-code">CopyFileW</span>, renaming it to <span id="inline-code">7z.exe</span>. Through this mechanism, the sample establishes persistence by 
                    ensuring execution after a system reboot.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_12_1.png" alt="malware_academic_exam_12_1" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    The image below shows the sample successfully copied into the Startup directory.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_12.png" alt="malware_academic_exam_12" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    The function <span id="inline-code">sub_401810</span> implements a <strong>DLL injection</strong> routine. It first invokes <span id="inline-code">sub_4017D0</span>, which is responsible for 
                    extracting an embedded resource from the executable. Specifically, the sample calls <span id="inline-code">FindResourceA</span>, <span id="inline-code">LoadResource</span>, 
                    <span id="inline-code">LockResource</span>, and <span id="inline-code">SizeofResource</span> to locate and load the resource, stored in <span id="inline-code">.rsrc</span> section, into memory.
                    <br><br>
                    The routine then invokes <span id="inline-code">sub_401380</span>, which is responsible for resolving a writable temporary directory. Inside this function, the sample calls 
                    <span id="inline-code">GetTempPathA</span> to retrieve the system temporary path: <span id="inline-code">C:\Users\student\AppData\Local\Temp</span>.
                    <br>
                    Then the routine calls <span id="inline-code">GetTempFileNameA</span>, passing the previously resolved temporary path as <span id="inline-code">lpPathName</span>. 
                    This API is used to generate a unique temporary filename within the temporary directory. In the analyzed environment, the generated file name was <span id="inline-code">scz52A9.tmp</span>, 
                    located in the system’s temporary folder.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_13.png" alt="malware_academic_exam_13" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    The figure below illustrates the presence of the generated temporary file within the system’s temporary directory. 
                    At this stage, the file has a size of 0 bytes because no data has been written yet; only an empty file with the <span id="inline-code">.tmp</span> extension has been created.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_14.png" alt="malware_academic_exam_14" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    Then the routine calls <span id="inline-code">CreateFileA</span> with <span id="inline-code">dwDesiredAccess = 0x40000000</span> (<strong>GENERIC_WRITE</strong>) to create the DLL file, 
                    named <span id="inline-code">scz52A9.tmp.dll</span>.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_15.png" alt="malware_academic_exam_15" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    Notably, the <span id="inline-code">.dll</span> extension itself is pushed onto the stack byte by byte, a technique used to hide the file type and prevent it from being easily identified 
                    during basic static analysis.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_15_1.png" alt="malware_academic_exam_15_1" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    At the end of the routine, the sample invokes <span id="inline-code">WriteFile</span> to write <span id="inline-code">0x2A00</span> bytes of malicious code into the previously created DLL file.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_16.png" alt="malware_academic_exam_16" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    After returning from <span id="inline-code">sub_4017D0</span>, the execution flow goes back to <span id="inline-code">sub_401810</span>. At this point, the sample calls 
                    <span id="inline-code">CreateProcessA</span> to spawn the process <span id="inline-code">explorer.exe</span> in a suspended state, as indicated by the flag 
                    <span id="inline-code">dwCreationFlags = 0x4</span> (<strong>CREATE_SUSPENDED</strong>). Additionally, the name of the target process to be injected is pushed onto the stack byte by byte, 
                    preventing it from being directly visible during a static analysis, as shown in the figure below.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_17.png" alt="malware_academic_exam_17" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    Then the execution continues with a call to the function <span id="inline-code">sub_401730</span>. Inside this routine, the sample invokes <span id="inline-code">sub_401430</span>, 
                    which is responsible for dynamically resolving critical Windows APIs. Specifically, it relies on <span id="inline-code">sub_401AC0</span> to decrypt, at runtime, the names of several 
                    sensitive functions that are commonly associated with process injection, including: <span id="inline-code">NtUnmapViewOfSection</span>, <span id="inline-code">SetThreadContext</span>,
                    <span id="inline-code">ResumeThread</span>, <span id="inline-code">NtCreateThreadEx</span>, <span id="inline-code">SuspendThread</span>, <span id="inline-code">VirtualAllocEx</span>, 
                    <span id="inline-code">GetThreadContext</span>, <span id="inline-code">WriteProcessMemory</span>, <span id="inline-code">LoadLibraryA</span>. 
                    <br>
                    The figure below illustrates a routine that processes a string stored in the <span id="inline-code">.data</span> section at address <span id="inline-code">0x453000</span>. 
                    The function first invokes a decryption routine to decode the string in memory, then calls <span id="inline-code">GetModuleHandle</span> and <span id="inline-code">GetProcAddress</span> 
                    to dynamically resolve and load the corresponding API at runtime. After that, the base offset is incremented by 4 bytes to point to the next encrypted string, and the same sequence of operations is repeated.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_18.png" alt="malware_academic_exam_18" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                    The figure below shows the memory address where the encrypted strings are stored.
                    <br>
                    <img src="../img/malware_academic_exam/malware_academic_exam_19.png" alt="malware_academic_exam_19" onclick="window.open(this.src, '_blank');"
                            width="650", onmouseover="this.style.cursor='zoom-in'"
                            onmouseout="this.style.cursor='default'">
                    <br><br>
                </p>
        </section>
    </section>

    <script src="../js/reading-time.js"></script>
</body>
</html>
