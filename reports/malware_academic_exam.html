<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Obscure RE and MA Dojo</title>
    
    <!-- link to fontawesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <!-- link to css file -->
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
      <a href="/obscure_blog" class="logo">Obscure<span class="cursor">_</span></a>
          <ul class="nav-links">
              <li><a href="../ctf_reversing/re.html">CTF Reverse Engineering</a></li>
          </ul>
    </nav>
    <section class="container">
        <section class="container-title">
            <h1>Malware Sample - Academic Exam</h1>
            <div class="post__bottom">
                <div class="post__author">
                    <a href="#" aria-label="ObscureRe">
                        <img class="post__author-image" src="../img/logo.png"
                            alt="Obscure's Picture">
                    </a>
                </div>
                <span>
                    Obscure_ &nbsp;·&nbsp; <span id="reading-time"></span>
                </span>
            </div>
        </section>
        <section>
            <h2>Introduction</h2>
            <p>
                This document details the analysis of a malware sample assigned for the <strong>Malware Analysis and Incident Forensics</strong> university exam at <strong>Sapienza University of Rome</strong>.
                The analysis focuses on understanding the internal structure, execution flow, and malicious capabilities of the sample.
            </p>
        </section>
        <section>
            <h2>Static Analysis</h2>
            <h3>Packing Detection</h3>
                <p>
                    Examining the sample with <strong>PE Studio</strong> quickly reveals numerous details. The sections are named UPX0 and UPX1. The entry point is not located in the first section. 
                    Both sections have write and execute permissions, the UPX1 section exhibits a high level of entropy, and the virtual size of the first section is significantly larger than its raw size. 
                    Since the entry point is located in the UPX1 section, it is likely that this section contains the decompression stub responsible for unpacking the original executable at runtime.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_1.png" alt="malware_academic_exam_1" onclick="window.open(this.src, '_blank');">
                    
                    The <strong>imports</strong> section contains some functions that are potential indicators or could reveal the sample's behavior. They are the following:
                </p>
                <ul>
                    <li><span id="inline-code">GetProcAddress</span>, <span id="inline-code">LoadLibraryA</span> which are typical of packed software that has to rebuild the IAT</li>
                    <li><span id="inline-code">MessageBoxA</span>, which means that the sample shows some message box</li>
                    <li><span id="inline-code">CryptStringToBinar</span>, which is probably used for obfuscation purposes</li>
                    <li><span id="inline-code">SHGetFolderPathA</span>, which means that the malware interacts with the filesystem</li>
                </ul>
                <br>
                <p>
                    The <strong>strings</strong> section contains a lot of junk-like strings, maybe they are just compressed or obfuscated. Some strings could reveal something about the behavior of the sample.
                    They are the following:
                </p>
                <ul>
                    <li>Function names (<span id="inline-code">GetProcAddress</span>, <span id="inline-code">LoadLibraryA</span>, <span id="inline-code">SHGetFolderPath</span>, 
                        <span id="inline-code">CryptStringToBinary</span>, <span id="inline-code">MessageBoxA</span>).</li>
                    <li>Library names (<span id="inline-code">NETAPI32.dll</span>, <span id="inline-code">kernel32.dll</span>, <span id="inline-code">shell32.dll</span>, <span id="inline-code">user32.dll</span>).</li>
                    <li>Extentions (<span id="inline-code">.jpg</span>, <span id="inline-code">.dll</span>).</li>
                    <li>A strange string <span id="inline-code">?mafuba&%s\%s.jpgUghn</span>, probably the sample create a file <span id="inline-code">.jpg</span> in a specific folder.</li>
                </ul>
                <br>
                <p>
                    The <strong>library</strong> section contains some libraries that could reveal the sample's behavior. They are the following:
                </p>
                <ul>
                    <li><span id="inline-code">shell32.dll</span>, which likely means that the sample interacts with other processes.</li>
                    <li><span id="inline-code">crypt32.dll</span>, which likely means that the malware performs some kind of encryption.</li>
                    <li><span id="inline-code">user32.dll</span>, which likely means that the sample performs user-level interactions such as showing a message box.</li>
                    <li><span id="inline-code">kernel32.dll</span>, which likely means that the sample uses some important function like 
                        <span id="inline-code">CreateFile</span>, <span id="inline-code">WriteFile</span>, <span id="inline-code">VirtualAlloc</span>, <span id="inline-code">WriteProcessMemory</span> and others.</li>
                </ul>
                <br>
                <p>
                    As section names suggested and as <strong>Detect It Easy</strong> confirmed, the sample was packed with UPX (version 3.96).
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_2.png" alt="malware_academic_exam_2" onclick="window.open(this.src, '_blank');">
                    
                </p>
            <h3>Unpacking</h3>
                <p>
                    To find the Original Entry Point of a packed sample it’s necessary to locate the tail jump, that is the jump that the packed sample performs to the beginning of the unpacked code after the unpacking 
                    stub has finished its operations. There are some indicators useful to recognize the tail jump: the instruction jumps to another section (in this case from UPX1 to UPX0), 
                    after the tail jump should be a bunch of garbage bytes and the destination was previously modified by the unpacking stub.
                    <br>
                    After opening the sample in <strong>x32dbg</strong> and starting at the entry point in UPX1 (<span id="inline-code">0x460C20</span>), the first instruction is a <span id="inline-code">pusha</span>,
                    used to save the register values at startup. Most likely, there will be a corresponding <span id="inline-code">popa</span> instruction just before the tail jump.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_3.png" alt="malware_academic_exam_3" onclick="window.open(this.src, '_blank');">
                    
                    There is a practical and reliable technique to identify the tail jump: place an HW breakpoint on memory access on the first 4 bytes of data pushed onto the stack at 
                    <span id="inline-code">esp</span> immediately after the first <span id="inline-code">pusha</ instruction. Before the jump there will be a <span id="inline-code">popa</span> 
                    instruction to restore the saved execution context.
                    <br>
                    The figure below highlights the tail jump located at address <span id="inline-code">0x460DC3</span>, which transfers execution to the unpacked code.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_4.png" alt="malware_academic_exam_4" onclick="window.open(this.src, '_blank');">
                    
                    After the tail jump, execution is transferred to a new code block starting at address <span id="inline-code">0x401E31</span>, as shown in the figure below. This address corresponds to 
                    the Original Entry Point of the unpacked executable.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_5.png" alt="malware_academic_exam_5" onclick="window.open(this.src, '_blank');">
                    
                    Once the OEP is identified, <strong>Scylla</strong> can be used to dump the unpacked binary. By selecting IAT Autosearch and providing the OEP address (<span id="inline-code">0x401E31</span>), 
                    <strong>Scylla</strong> automatically locates the Import Address Table and retrieves its virtual address and size. The import list can then be extracted using Get Imports; 
                    any invalid entries, as shown in the screenshot, can be manually removed. Afterward, the process memory is dumped by clicking Dump, generating a file with the <span id="inline-code">_dump</span> suffix. 
                    Finally, using Fix Dump on the generated file produces a new executable (with the <span id="inline-code">_SCY</span> suffix) containing the reconstructed IAT.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_6.png" alt="malware_academic_exam_6" onclick="window.open(this.src, '_blank');">
                    
                </p>
            <h2>Dynamic Analysis</h2>
                <p>
                    After opening the unpacked sample in <strong>IDA</strong>, the binary appears as shown in the figure below.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_7.png" alt="malware_academic_exam_7" onclick="window.open(this.src, '_blank');">
                    
                    First, the sample invokes the function <span id="inline-code">sub_4010C0</span>. Within this function, the sample resolves and calls <span id="inline-code">GetTickCount</span>, 
                    whose API name and the corresponding <span id="inline-code">kernel32.dll</span> library are XOR-encrypted and decrypted at runtime using the key <span id="inline-code">0x30</span>.
                    Additionally, the strings required to load <span id="inline-code">GetTickCount</span> are pushed onto the stack byte by byte, a technique used to evade basic static analysis.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_7_1.png" alt="malware_academic_exam_7_1" onclick="window.open(this.src, '_blank');">
                    
                    The retrieved tick count is then compared against 1800000 milliseconds. If the system uptime exceeds this threshold, the function returns 0 and the sample continues execution. 
                    Otherwise, the program invokes Sleep with a timeout of <span id="inline-code">0xFFFFFFFF</span>, effectively pausing execution for an extremely long period.
                    <br><br>
                    In <span id="inline-code">sub_4011C0</span>, the sample first calls <span id="inline-code">GetCurrentProcessId</span> to retrieve the identifier of the current process. 
                    It then invokes <span id="inline-code">CreateToolhelp32Snapshot</span> with <span id="inline-code">dwFlags = 0x8</span> to obtain a snapshot used to enumerate running processes and loaded modules. 
                    The functions <span id="inline-code">Module32FirstW</span> and <span id="inline-code">Module32NextW</span> are subsequently used to iterate through the module list.
                    <br><br>
                    During this enumeration, the sample checks for the presence of specific strings within module names, including <strong>daimao</strong>, <strong>piccolo</strong>, <strong>zamasu</strong>, 
                    <strong>dercori</strong>, and <strong>frost</strong>. If any of these strings are found, execution proceeds to <span id="inline-code">sub_401000</span>. 
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_7_2.png" alt="malware_academic_exam_7_2" onclick="window.open(this.src, '_blank');">
                    
                    Within <span id="inline-code">sub_401000</span>, the sample calls <span id="inline-code">SHGetFolderPathA</span> with <span id="inline-code">CSIDL = 0x27</span> to retrieve the path to the user’s Pictures directory: 
                    "<span id="inline-code">C:\Users\student\Pictures</span>".
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_8.png" alt="malware_academic_exam_8" onclick="window.open(this.src, '_blank');">
                    
                    The function then invokes <span id="inline-code">CreateFileA</span> with <span id="inline-code">dwDesiredAccess = 0x40000000</span> (<strong>GENERIC_WRITE</strong>) to create or open a file, 
                    followed by a call to <span id="inline-code">WriteFile</span> to write the file <span id="inline-code">mafuba.jpg</span> into the previously identified Pictures directory.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_9.png" alt="malware_academic_exam_9" onclick="window.open(this.src, '_blank');">
                    
                    The figure below shows that the file <span id="inline-code">mafuba.jpg</span> has been successfully created in the Pictures directory.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_10.png" alt="malware_academic_exam_10" onclick="window.open(this.src, '_blank');">
                    
                    The routine then calls <span id="inline-code">SystemParametersInfoA</span> with <span id="inline-code">uiAction = 0x14</span>, causing the previously written image to be set as the desktop wallpaper.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_11.png" alt="malware_academic_exam_11" onclick="window.open(this.src, '_blank');">
                    
                    Subsequently, the function <span id="inline-code">sub_401900</span> is executed. This routine calls <span id="inline-code">SHGetFolderPathW</span> with <span id="inline-code">CSIDL = 0x07</span>
                    to retrieve the path of the Startup folder: <span id="inline-code">C:\Users\student\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span>. It then creates a copy of the current 
                    executable in this directory using <span id="inline-code">CopyFileW</span>, renaming it to <span id="inline-code">7z.exe</span>. Through this mechanism, the sample establishes persistence by 
                    ensuring execution after a system reboot.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_12_1.png" alt="malware_academic_exam_12_1" onclick="window.open(this.src, '_blank');">
                    
                    The image below shows the sample successfully copied into the Startup directory.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_12.png" alt="malware_academic_exam_12" onclick="window.open(this.src, '_blank');">
                    
                    The function <span id="inline-code">sub_401810</span> implements a <strong>DLL injection</strong> routine. It first invokes <span id="inline-code">sub_4017D0</span>, which is responsible for 
                    extracting an embedded resource from the executable. Specifically, the sample calls <span id="inline-code">FindResourceA</span>, <span id="inline-code">LoadResource</span>, 
                    <span id="inline-code">LockResource</span>, and <span id="inline-code">SizeofResource</span> to locate and load the resource, stored in <span id="inline-code">.rsrc</span> section, into memory.
                    <br><br>
                    The routine then invokes <span id="inline-code">sub_401380</span>, which is responsible for resolving a writable temporary directory. Inside this function, the sample calls 
                    <span id="inline-code">GetTempPathA</span> to retrieve the system temporary path: <span id="inline-code">C:\Users\student\AppData\Local\Temp</span>.
                    <br>
                    Then the routine calls <span id="inline-code">GetTempFileNameA</span>, passing the previously resolved temporary path as <span id="inline-code">lpPathName</span>. 
                    This API is used to generate a unique temporary filename within the temporary directory. In the analyzed environment, the generated file name was <span id="inline-code">scz52A9.tmp</span>, 
                    located in the system’s temporary folder.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_13.png" alt="malware_academic_exam_13" onclick="window.open(this.src, '_blank');">
                    
                    The figure below illustrates the presence of the generated temporary file within the system’s temporary directory. 
                    At this stage, the file has a size of 0 bytes because no data has been written yet; only an empty file with the <span id="inline-code">.tmp</span> extension has been created.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_14.png" alt="malware_academic_exam_14" onclick="window.open(this.src, '_blank');">
                    
                    Then the routine calls <span id="inline-code">CreateFileA</span> with <span id="inline-code">dwDesiredAccess = 0x40000000</span> (<strong>GENERIC_WRITE</strong>) to create the DLL file, 
                    named <span id="inline-code">scz52A9.tmp.dll</span>.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_15.png" alt="malware_academic_exam_15" onclick="window.open(this.src, '_blank');">
                    
                    Notably, the <span id="inline-code">.dll</span> extension itself is pushed onto the stack byte by byte, a technique used to hide the file type and prevent it from being easily identified 
                    during basic static analysis.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_15_1.png" alt="malware_academic_exam_15_1" onclick="window.open(this.src, '_blank');">
                    
                    At the end of the routine, the sample invokes <span id="inline-code">WriteFile</span> to write <span id="inline-code">0x2A00</span> bytes of malicious code into the previously created DLL file.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_16.png" alt="malware_academic_exam_16" onclick="window.open(this.src, '_blank');">
                    
                    After returning from <span id="inline-code">sub_4017D0</span>, the execution flow goes back to <span id="inline-code">sub_401810</span>. At this point, the sample calls 
                    <span id="inline-code">CreateProcessA</span> to spawn the process <span id="inline-code">explorer.exe</span> in a suspended state, as indicated by the flag 
                    <span id="inline-code">dwCreationFlags = 0x4</span> (<strong>CREATE_SUSPENDED</strong>). Additionally, the name of the target process to be injected is pushed onto the stack byte by byte, 
                    preventing it from being directly visible during a static analysis, as shown in the figure below.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_17.png" alt="malware_academic_exam_17" onclick="window.open(this.src, '_blank');">
                    
                    Then the execution continues with a call to the function <span id="inline-code">sub_401730</span>. Inside this routine, the sample invokes <span id="inline-code">sub_401430</span>, 
                    which is responsible for dynamically resolving critical Windows APIs. Specifically, it relies on <span id="inline-code">sub_401AC0</span> to decrypt, at runtime, the names of several 
                    sensitive functions that are commonly associated with process injection, including: <span id="inline-code">NtUnmapViewOfSection</span>, <span id="inline-code">SetThreadContext</span>,
                    <span id="inline-code">ResumeThread</span>, <span id="inline-code">NtCreateThreadEx</span>, <span id="inline-code">SuspendThread</span>, <span id="inline-code">VirtualAllocEx</span>, 
                    <span id="inline-code">GetThreadContext</span>, <span id="inline-code">WriteProcessMemory</span>, <span id="inline-code">LoadLibraryA</span>. 
                    <br>
                    The figure below illustrates a routine that processes a string stored in the <span id="inline-code">.data</span> section at address <span id="inline-code">0x453000</span>. 
                    The function first invokes a decryption routine to decode the string in memory, then calls <span id="inline-code">GetModuleHandle</span> and <span id="inline-code">GetProcAddress</span> 
                    to dynamically resolve and load the corresponding API at runtime. After that, the base offset is incremented by 4 bytes to point to the next encrypted string, and the same sequence of operations is repeated.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_18.png" alt="malware_academic_exam_18" onclick="window.open(this.src, '_blank');">
                    
                    The figure below shows the memory address where the encrypted strings are stored.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_19.png" alt="malware_academic_exam_19" onclick="window.open(this.src, '_blank');">
                    
                    In <span id="inline-code">sub_401730</span>, the sample calls <span id="inline-code">VirtualAllocEx</span> to allocate <span id="inline-code">0x34</span> bytes 
                    (stored in <span id="inline-code">edx</span>) of memory within the address space of <span id="inline-code">explorer.exe</span>, using the process handle stored in 
                    <span id="inline-code">eax</span>. 
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_20.png" alt="malware_academic_exam_20" onclick="window.open(this.src, '_blank');">
                    
                    It then calls <span id="inline-code">WriteProcessMemory</span>, passing the path of the malicious DLL <span id="inline-code">C:\Users\student\AppData\Local\Temp\SCZ<random string>.dll</span>, 
                    as shown in the figure below. This path is stored in <span id="inline-code">ebp+buffer</span> and is written into the memory of the target process. 
                    It writes this path at address <span id="inline-code">0x3080000</span> (this address dynamically changes at each execution of the sample).
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_21.png" alt="malware_academic_exam_21" onclick="window.open(this.src, '_blank');">
                    
                    The figure below shows the retrieved malicious DLL path at runtime.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_22.png" alt="malware_academic_exam_22" onclick="window.open(this.src, '_blank');">
                    
                    Finally, the routine performs a system call to <span id="inline-code">NtCreateThreadEx</span> to create a new thread inside the target process, specifying a desired access value of 
                    <span id="inline-code">0x10000000</span> (<strong>THREAD_ALL_ACCESS</strong>) and passing <span id="inline-code">LoadLibraryA</span> (its <span id="inline-code">hModule</span> is stored 
                    in <span id="inline-code">var_C</span>) as the thread start routine. In this way, the newly created thread loads the malicious DLL into the address space of 
                    <span id="inline-code">explorer.exe</span>, completing the injection process. The output of the function, corresponding to the handle of the created thread, is stored in 
                    the <span id="inline-code">edx</span> register which is the first parameter passed to the function.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_23.png" alt="malware_academic_exam_23" onclick="window.open(this.src, '_blank');">
                    
                    By opening <strong>Process Hacker</strong>, it is possible to observe that at memory address <span id="inline-code">0x3080000</span> the DLL path has been written. This path is later used by 
                    <span id="inline-code">LoadLibrary</span> to load the malicious DLL within the newly created thread.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_24.png" alt="malware_academic_exam_24" onclick="window.open(this.src, '_blank');">
                    
                </p>
            <h3>Analyzing DLL</h3>
                <p>
                    When the DLL file is opened in <strong>IDA</strong>, the following code can be observed:
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_25.png" alt="malware_academic_exam_25" onclick="window.open(this.src, '_blank');">
                    
                    After opening the extracted DLL with <strong>IDA</strong> and executing it using <span id="inline-code">rundll32.exe</span>, the code can be analyzed in detail. 
                    From <span id="inline-code">DllMain</span>, it is possible to follow the execution flow to <span id="inline-code">lpStartAddress</span>, which contains the core malicious logic.
                    <br><br>
                    The routine first calls <span id="inline-code">sub_10001000</span>, which invokes <span id="inline-code">WSAStartup</span> to initialize the Windows Sockets API and resolve the required 
                    networking functions. It then attempts to establish a network connection to the host <span id="inline-code">34.44.19.185</span> on port 80. If the connection is successful, 
                    the DLL prints the string "<span id="inline-code">TARGET HOST CONNECTIONS:\n%s\n</span>", where %s corresponds to the IPv4 address and the source port assigned by the Windows operating system.
                    In my case, the resolved connection endpoint is <span id="inline-code">10.0.2.15:49808</span>.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_26.png" alt="malware_academic_exam_26" onclick="window.open(this.src, '_blank');">
                
                    By using <strong>Process Hacker</strong> and triggering the function responsible for the network communication, it is possible to observe the active connection to the C2 server. 
                    It is possible to note that the source port shown in the figure below differs from the one previously reported. This behavior because it is performed a second connection to the C2 server and
                    the source port is randomly generated by operating system.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_27.png" alt="malware_academic_exam_27" onclick="window.open(this.src, '_blank');">
                    
                    Finally, by using <strong>Wireshark</strong>, it is possible to capture the network traffic, observe the connection to the C2 server, and analyze the payload of the packets sent to it.
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_28.png" alt="malware_academic_exam_28" onclick="window.open(this.src, '_blank');">
                    
                    <img class="post-image" src="../img/malware_academic_exam/malware_academic_exam_29.png" alt="malware_academic_exam_29" onclick="window.open(this.src, '_blank');">
                </p>
        </section>
    </section>

    <script src="../js/reading-time.js"></script>
</body>
</html>
